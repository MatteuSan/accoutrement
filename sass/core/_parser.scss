/// # Core Map API
/// The Accoutrement tools rely on a map syntax
/// inspired by functional programming:
///
/// ```scss
/// $map: (
///   'original-value': 3em,
///
///   // explicit sub-map with 'value' and function properties:
///   'new-value': (
///     'value': '#original-value' ,
///     'times': 2,
///     'minus': 0.5,
///   ),
///
///   // implicit value/function shorthand:
///   'new-value-2': '#original-value' ('times': 2, 'minus': 0.5),
/// );
/// ```
///
/// Each function in the function map
/// (e.g. `times` and `minus` above)
/// will be run in order --
/// with any associated arguments
/// (`e.g. minus(times(#original-value, 2), 0.5)`) --
/// to create a new value based on the base `value`.
///
/// @group core-api


// Token Get
// ---------
/// The primary function for accessing and parsing
/// accoutrement map values.
/// Each accoutrement plugin creates a shortcut wrapper function
/// for the specific map associated with that data-type.
/// You can do the same, or use it directly
/// to turn any arbitrary map into an accoutrement map.
///
/// @group core-api
/// @example scss - Access a map directly
///   $map: (
///     'original-value': 3em,
///     'new-value': '#original-value' ('times': 2, 'minus': 0.5),
///   );
///   /*! #{get-token($map, 'new-value')} */
/// @example scss - Write your own shortcut plugin for specific maps
///   $my-map: ('main': 32em);
///   @function get($key) { @return get-token($my-map, $key); }
///   /*! #{get('main')} */
///
/// @param {map} $map -
///   A map of token definitions to reference against
/// @param {*} $key -
///   The original key or value to be parsed for `#alias` tags
/// @return {*} -
///   Updated `$needle` value
///   in the same format as the original,
///   but with all `#alias` tags replaced
@function get-token(
  $map,
  $key
) {
  $key: map-get($map, $key) or $key;
  @return _a_get($map, $key);
}


// Get
// ---
/// Adds value/do functionality
/// to the value-parsing power of `_a_parse()`.
/// Functions can be added as a map at the end of a value --
/// but some use-cases may confuse the parser,
/// so we provide a more explicit map option with a `value` key,
/// forllowed by functions and args.
///
/// @access private
///
/// @param {map} $map -
///   A map of token definitions to reference against
/// @param {*} $key -
///   Map access key for parsing
/// @return {*} -
///   Final parsed and adjusted value from the original map
@function _a_get(
  $map,
  $key
) {
  $type: type-of($key);
  $do: null;
  $value: $key;

  // break out `do` maps…
  @if ($type == 'map') and map-get($key, 'value') {
    $value: map-get($key, 'value');
    $do: map-remove($key, 'value');
  } @else if index('list' 'arglist', $type) {
    $final: nth($key, -1);

    @if (length($key) > 1) and (type-of($final) == 'map') {
      $do: $final;
      $value: _a_remove-nth($key, -1);
      $value: if(length($value) == 1, nth($value, 1), $value);
    }
  }

  // resolve any #alias tags…
  $value: _a_parse($map, $value);

  // make any necessary adjustments…
  @if ($do) {
    @each $name, $args in $do {
      $value: _a_do($map, $name, $value, $args...)
    }
  }

  @return $value;
}


// Parse Alias
// -----------
/// Handles recursive parsing for list/map values.
///
/// @access private
///
/// @param {map} $haystack -
///   A map of terms to reference tags against
/// @param {*} $needle -
///   The original value to be parsed for `#alias` tags
/// @return {*} -
///   Updated `$needle` value
///   in the same format as the original,
///   but with all `#alias` tags replaced
@function _a_parse(
  $haystack,
  $needle
) {
  $type: type-of($needle);

  // handle list values…
  @if index('list' 'arglist', $type) {
    $new: _a_list-template($needle);

    // handle each item in the list…
    @each $bit in $needle {
      $new: append($new, _a_get($haystack, $bit));
    }

    @return $new;
  }

  // handle map values…
  @if ($type == 'map') {
    $new: ();

    // handle each value in the map…
    @each $key, $value in $needle {
      $key: _a_get($haystack, $key);
      $value: _a_get($haystack, $value);
      $needle: ($key: $value);
      $new: map-merge($new, $needle);
    }

    @return $new;
  }

  @if ($type == 'string') {
    $needle: _a_replace($haystack, $needle);
  }

  @return $needle;
}


// Replace
// -------
/// Search for `#alias` mentions within a string,
/// and return a list of unique mentions with `#` removed.
///
/// @access private
///
/// @param {map} $haystack -
///   A map of terms to reference tags against
/// @param {string} $string -
///   The original string to be parsed for `#alias` tags
/// @return {list} -
///   List of unique `#alias` mentions with the `#` removed
@function _a_replace(
  $haystack,
  $string
) {
  $return: $string;
  $start: str-index($string, '#');

  // replace aliases…
  @if $start {
    // define the terms…
    $ends: (' ', '(', ')', '/', '\\', '#', '[', ']', '{', '}');

    // find the end…
    $remainder: str-slice($string, $start + 1);
    $end: str-length($remainder);

    @each $char in $ends {
      $has: str-index($remainder, $char);
      $end: if($has, min($has - 1, $end), $end);
    }

    $end: $end - str-length($remainder) - 1;

    // the bits!
    $before: str-slice($string, 1, $start - 1);
    $replace: str-slice($string, $start, $end);
    $after: if(($end < -1), str-slice($string, $end + 1), '');

    // replace the token…
    $token: str-slice($replace, 2);
    $got: get-token($haystack, $token);
    $return: if(($got == $token), $replace, $got);

    // put it back together…
    @if (str-length($before) > 0) {
      $return: '#{$before}#{$return}';
    }

    @if (str-length($after) > 0) {
      $after: _a_replace($haystack, $after);
      $return: '#{$return}#{$after}';
    }
  }

  @return $return;
}


// Do
// --
/// Applies any ratio or function adjustments
/// to Accoutrement map values
///
/// @access private
///
/// @param {map} $source -
///   A map of terms to reference tags against
/// @param {string | ratio | function} $name -
///   The ratio or function to use in manipulation
/// @param {*} $value -
///   The value to be manipulated
/// @param {arglist} $args... -
///   Any arguments required for a function call
/// @return {*} -
///   Manipulated value
@function _a_do(
  $source,
  $name,
  $value,
  $args...
) {
  // Allow internal map references
  $name: _a_get($source, $name);
  $args: _a_get($source, $args);

  // Handle null args…
  @if (length($args) == 1) {
    $args: nth($args, 1);
  }

  // Try ratios first
  @if type-of($value == 'number') {
    $ratio: ratio($name);

    @if ($ratio == 'linear') {
      @return $value * $args;
    } @else if (type-of($ratio) == 'number') {
      $multiplier: _a_pow($ratio, $args);
      @return $value * $multiplier;
    }
  }

  // Fallback to function calls
  $function: _a_get-function($name, $error: false);

  @if ($function) {
    @if ($args) {
      @return call($function, $value, $args...);
    } @else {
      @return call($function, $value);
    }
  }

  // error
  @error 'No ratio or function named #{$name}';
}
