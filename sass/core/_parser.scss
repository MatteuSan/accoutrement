/// # Accessing Maps
/// @group core-get

// Get Token
// ---------
/// The primary function for accessing and parsing
/// accoutrement map values.
/// Each accoutrement plugin creates a shortcut wrapper function
/// for the specific map associated with that data-type.
/// You can do the same, or use it directly
/// to turn any arbitrary map into an accoutrement map.
///
/// @since 1.0.0 -
/// - NEW: Accepts `$do` map argument,
///   for on-the-fly adjustments
///
/// @group core-get
/// @example scss - Access a map directly
///   $map: (
///     'original-value': 3em,
///     'new-value': '#original-value' (
///       'times': 2,
///       'minus': 0.5
///     ),
///   );
///   /*! New Value: #{get-token($map, 'new-value')} */
/// @example scss - Write your own shortcut plugin for specific maps
///   @function get($key) {
///     @return get-token($my-map, $key);
///   }
///
///   $my-map: ('main': 32em);
///   /*! Main: #{get('main')} */
///
/// @param {map} $map -
///   A map of token definitions to reference against
/// @param {*} $key -
///   The original key or value to be parsed for `#alias` tags
/// @param {map | null} $do [null] -
///   A final map of function/ratio adjustments to run on the returned value
/// @return {*} -
///   The parsed value of any key in a given map
@function get-token(
  $map,
  $key,
  $do: null
) {
  // @debug '#{$_}-->';
  // @debug $key;
  $key: map-get($map, $key) or $key;
  // @debug $key;
  $key: _a_get($map, $key);
  // @debug $key;
  // @debug '#{$_}<--';
  // @debug $map;
  // @debug _a_map-keys-values-deep($map);
  @return _a_do-each($map, $key, $do);
}


// Get
// ---
/// Adds value/do functionality
/// to the value-parsing power of `_a_parse()`.
/// Functions can be added as a map at the end of a value --
/// but some use-cases may confuse the parser,
/// so we provide a more explicit map option with a `value` key,
/// forllowed by functions and args.
///
/// @access private
///
/// @param {map} $map -
///   A map of token definitions to reference against
/// @param {*} $key -
///   Map access key for parsing
/// @return {*} -
///   Final parsed and adjusted value from the original map
@function _a_get(
  $map,
  $key
) {
  $type: type-of($key);
  $do: null;
  $value: $key;

  $_: $_ + '-g- ' !global;

  // break out `do` maps…
  @if ($type == 'map') and map-get($key, 'value') {
    $value: map-get($key, 'value');
    $do: map-remove($key, 'value');
  } @else if index('list' 'arglist', $type) {
    $final: nth($key, -1);

    @if (length($key) > 1) and (type-of($final) == 'map') {
      $do: $final;
      $value: _a_remove-nth($key, -1);
      $value: if(length($value) == 1, nth($value, 1), $value);
    }
  }

  // resolve any #alias tags…
  $value: _a_parse($map, $value);

  // make any necessary adjustments…
  $value: _a_do-each($map, $value, $do);

  $_: _a_str-replace($_, '-g- ', '') !global;
  @return $value;
}


// Parse
// -----
/// Handles recursive parsing for list/map values.
///
/// @access private
///
/// @param {map} $haystack -
///   A map of terms to reference tags against
/// @param {*} $needle -
///   The original value to be parsed for `#alias` tags
/// @return {*} -
///   Updated `$needle` value
///   in the same format as the original,
///   but with all `#alias` tags replaced
@function _a_parse(
  $haystack,
  $needle
) {
  $type: type-of($needle);

  $_: $_ + '-p- ' !global;
  // @debug $type;

  // handle list values…
  @if index('list' 'arglist', $type) {
    $new: _a_list-template($needle);

    // handle each item in the list…
    @each $bit in $needle {
      $new: append($new, _a_get($haystack, $bit));
    }

    @return $new;
  }

  // handle map values…
  @if ($type == 'map') {
    $new: ();
    $keys: map-keys($needle);
    $values: map-values($needle);
    $needleKey: null;
    // @debug map-values($haystack);
    // @debug $needle;
    // @debug index(map-values($haystack), $needle);
    @each $k, $v in $haystack {
      // @debug $v == $needle;
      @if $v == $needle {
        $needleKey: $k;
      }
    }
    // $needleKey: nth( map-keys($haystack), index(map-values($haystack), $needle) );

    // handle each value in the map…
    @each $key, $value in $needle {
      $new: ();
      $index: index($keys, $key);
      @debug '#{$_}';

      // @debug '#{$_}➡️ key: `#{$key}`';
      @debug '#{$_}➡️ value: `#{$value}`';

      $innerKey: _a_get($needle, $key);
      // @debug '#{$_}✅ innerKey: `#{$innerKey}` from `#{$needle}`';
      $innerValue: _a_get($needle, $value);
      @debug '#{$_}✅ innerValue: `#{$innerValue}`';// from `#{$needle}`';
      @debug '#{$_}❓ innerValue: `#{_a_get(map-merge($needle, $haystack), $value)}`';// from `#{$needle}`';

      $outerKey: _a_get($haystack, $key);
      $outerValue: null;
      @if type-of($value) == 'map' {
        $_: $_ + '-v- ' !global;

        $mash: map-merge(map-merge($value, $needle), $haystack);
        // @debug $mash;
        $outerValue: _a_get($mash, $value);
        // @debug '#{$_}#{_a_get($mash, "#baz")}';
        // @debug '#{$_}#{_a_get($mash, "#bar")}';

        $_: _a_str-replace($_, '-v- ', '') !global;
      }
      @else {
        $outerValue: _a_get($haystack, $value);
      }
      // @debug '#{$_}✅ outerKey: `#{$outerKey}` from `#{$haystack}`';
      @debug '#{$_}✅ outerValue: `#{$outerValue}`';// from `#{$haystack}`';



      // @debug '#{$_}key: `#{$key}` | direct: `#{$directValue}` | inner: `#{$innerValue}` | outer: `#{$outerValue}`';

      // @debug $value type-of($value);
      // @debug $innerValue type-of($innerValue);

      @if $innerKey == $key or type-of($key) == 'map' or type-of($key) == 'list' {
        $key: $outerKey;
      }
      @else {
        $key: $innerKey;
      }

      // $value: $innerValue;
      @if $innerValue == $value or type-of($value) == 'map' or type-of($value) == 'list' {
        $value: $outerValue;
      }
      @else {
        $value: $innerValue;
      }

      // @debug '#{$_}⬅️ key: `#{$key}`';
      @debug '#{$_}⬅️ value: `#{$value}`';

      // @debug ($key: $value);

      // $new: map-merge($needle, ($key: $value));
      $keys: set-nth($list: $keys, $n: $index, $value: $key);
      $values: set-nth($list: $values, $n: $index, $value: $value);
      @each $k in $keys {
        $new: map-merge($new, (
          $k: nth($values, index($keys, $k))
        ));
      }
      // @debug $needle;
      // @debug $new;
      $needle: $new;
      @debug '#{$_}new needle: `#{$needle}` for key `#{$needleKey}` (or `#{$key}`)';

      // @if $needleKey {
      //   $newHaystack: map-merge($haystack, ($needleKey: $needle));
      //   $haystack: $newHaystack;
      //   @debug '#{$_}new haystack: `#{$haystack}`';
      // }


      // check both maps
      // $layers: map-merge($haystack, $needle);
      // $key: _a_get($layers, $key);
      // $value: _a_get($layers, $value);

      // // update pair
      // $needle: ($key: $value);

      // @if type-of($value) == 'map' {
      //   $value: _a_get($haystack, $value);
      //   $needle: map-merge($needle, ($key: $value));
      // }

      // $new: map-merge($new, $needle);
    }

    // @debug $new;
    // @debug $haystack;

    $_: _a_str-replace($_, '-p- ', '') !global;
    @return $new;
  }

  @if ($type == 'string') {
    $needle: _a_replace($haystack, $needle);
  }

  $_: _a_str-replace($_, '-p- ', '') !global;
  @return $needle;
}

@function _a_parseNEW(
  $haystack,
  $needle
) {
  $type: type-of($needle);
  @debug '#{$_}...  starting _a_parse for: `#{$needle}`';
  // @debug #{'needle and type:' $needle $type};

  // handle list values…
  @if index('list' 'arglist', $type) {
    $new: _a_list-template($needle);

    // handle each item in the list…
    @each $bit in $needle {
      $new: append($new, _a_get($haystack, $bit));
    }

    @debug '#{$_}>>> returning `#{$new}` for list';
    @return $new;
  }

  // handle map values…
  @if ($type == 'map') {
    $new: ();

    // handle each value in the map…
    @each $key, $value in $needle {
      // check both maps
      $layers: map-merge($haystack, $needle);
      $key: _a_get($layers, $key);
      $value: _a_get($layers, $value);
      // @debug $key $value;

      // @debug $needle;
      // update pair
      $needle: ($key: $value);

      @if type-of($value) == 'map' {
        // @debug $haystack;
        // @debug $layers;
        // @debug $needle;
        $value: _a_get($haystack, $value);
        // @debug $value;
        $needle: map-merge($needle, ($key: $value));
        // @debug $needle;
      }

      $new: map-merge($new, $needle);
    }

    @debug '#{$_}>>> returning `#{$new}` for map';
    @return $new;
  }

  @if ($type == 'string') {
    // @debug #{$needle '--->' _a_map-get-deep( $haystack, $needle )};
    $needle: _a_replace($haystack, $needle);
  }

  @debug '#{$_}>>> returning `#{$needle}` for string input`';
  @return $needle;
}


// Replace
// -------
/// Search for `#alias` mentions within a string,
/// and return a list of unique mentions with `#` removed.
///
/// @access private
///
/// @param {map} $haystack -
///   A map of terms to reference tags against
/// @param {string} $string -
///   The original string to be parsed for `#alias` tags
/// @return {any} -
///   Input $string, with #alias mentions replaced
@function _a_replace(
  $haystack,
  $string
) {
  // $gstring: $string;
  // replace aliases…
  @if str-index($string, '#') {
    // @debug '#{$_}`#{$string}` is a hash. Searching in `#{$haystack}`';
    $keys: map-keys($haystack);
    // @debug $keys;
    // @debug _a_map-keys-deep($haystack);
    // check longest keys first, in case of overlap
    @each $key in _a_str-length-sort($keys) {
      $hash: '##{$key}';

      // @debug '#{$_}Type of `#{$string}` is `#{type-of($string)}`.';
      @if (type-of($string) == 'string') and str-index($string, $hash) {
        // @debug '#{$_}String `#{$string}` matched hash `#{$hash}` from key `#{$key}`';
        // $gnew: map-get($haystack, $key);
        $new: get-token($haystack, $key);
        // @debug '#{$_}Found new `#{$new}`';
        // @debug '#{$_}Found gnew `#{$gnew}`';
        // $gnew: _a_parse($haystack, $gnew);
        $string: _a_str-replace($string, $hash, $new, 'all');
        // $gstring: _a_str-replace($gstring, $hash, $gnew, 'all');
      }
    }
  }

  // @debug '#{$_}Returning string `#{$string}` from replace';
  // @debug '#{$_}Returning gstring `#{$gstring}` from replace';
  @return $string;
}

@function _a_replaceNEW(
  $haystack,
  $string
) {
  // replace aliases…
  @if str-index($string, '#') {
    $unhash: _a_str-replace($string, '#', '');
    @debug $unhash type-of($unhash);
    $flatten: _a_map-keys-values-deep($haystack);
    $keys: map-get($flatten, 'keys');
    $values: map-get($flatten, 'values');
    $index: index( $keys, $unhash );
    $newval: nth( $values, $index );
    @debug $index $newval;
    // check longest keys first, in case of overlap
    // @debug map-keys($haystack);
    // @debug map-values($haystack);
    // @each $key in _a_str-length-sort(_a_map-keys-deep($haystack)) {
    @each $key in $keys {
      $hash: '##{$key}';
      @debug $hash $newval;
      // @debug index($keys, $key) '--' $key $hash $string;
      // @debug $index '--' $key $hash $string nth($values, ($index or 1)) str-index($string, $hash);

      @if (type-of($string) == 'string') and str-index($string, $hash) {
        @debug '#{$_}^^^     going back in to find `#{$key}`';
        $new: get-token($haystack, $key);
      // @if (type-of($string) == 'string') and (type-of($index) == 'number') {
      //   $newkey: nth( $keys, $index );
      //   @debug '#{$_}^^^     going back in to find `#{$newkey}`';
      //   $new: get-token($haystack, $newkey);

        // @debug #{'------>' $new};
        $string: _a_str-replace($string, $hash, $new, 'all');
      }
    }
  }

  @return $string;
}


@function _a_origin(
  $map,
  $key
) {
  $name: null;

  @while map-has-key($map, $key) {
    $name: $key;
    $try: map-get($map, $key);

    @if (type-of($try) == 'string') and (str-index($try, '#') == 1) {
      $try: str-slice($try, 2);
    }

    $key: $try;
  }

  @return $name;
}


// Do Each
// -------
/// A wrapper for calling `_a_do()`
/// over each item in an adjustments list.
///
/// @access private
///
/// @param {map} $map -
///   A map of terms to reference tags against
/// @param {*} $value -
///   The value to be manipulated
/// @param {map | null} $do [null] -
///   A map of function/ratio adjustments to run on the returned value
@function _a_do-each(
  $map,
  $value,
  $do: null
) {
  @if ($do) {
    @each $name, $args in $do {
      $value: _a_do($map, $name, $value, $args...);
    }
  }

  @return $value;
}


// Do
// --
/// Applies any ratio or function adjustments
/// to Accoutrement map values
///
/// @access private
///
/// @param {map} $source -
///   A map of terms to reference tags against
/// @param {string | ratio | function} $name -
///   The ratio or function to use in manipulation
/// @param {*} $value -
///   The value to be manipulated
/// @param {arglist} $args... -
///   Any arguments required for a function call
/// @return {*} -
///   Manipulated value
/// @throws No ratio or function found with the given name
@function _a_do(
  $source,
  $name,
  $value,
  $args...
) {
  // Allow internal map references
  $name: _a_get($source, $name);
  $args: _a_get($source, $args);

  // Handle null args…
  @if (length($args) == 1) {
    $args: nth($args, 1);
  }

  // Try ratios first
  @if type-of($value == 'number') {
    $ratio: ratio($name);

    @if ($ratio == 'linear') {
      @return $value * $args;
    } @else if (type-of($ratio) == 'number') {
      $multiplier: _a_pow($ratio, $args);
      @return $value * $multiplier;
    }
  }

  // Fallback to function calls
  $function: _a_get-function($name);

  @if ($function) {
    @if ($args) {
      @return call($function, $value, $args...);
    } @else {
      @return call($function, $value);
    }
  }

  // error
  @return _a_error(
    'No ratio or function named `#{$name}`',
    '_a_do'
  );
}
