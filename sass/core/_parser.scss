/// # Core Map API
/// The Accoutrement tools rely on a map syntax
/// inspired by functional programming:
///
/// ```scss
/// $map: (
///   'original-value': 3em,
///
///   // explicit sub-map with 'value' and function properties:
///   'new-value': (
///     'value': '#original-value' ,
///     'times': 2,
///     'minus': 0.5,
///   ),
///
///   // implicit value/function shorthand:
///   'new-value-2': '#original-value' ('times': 2, 'minus': 0.5),
/// );
/// ```
///
/// Each function in the function map
/// (e.g. `times` and `minus` above)
/// will be run in order --
/// with any associated arguments
/// (`e.g. minus(times(#original-value, 2), 0.5)`) --
/// to create a new value based on the base `value`.
///
/// @group core-api


// Token Get
// ---------
/// The primary function for accessing and parsing
/// accoutrement map values.
/// Each accoutrement plugin creates a shortcut wrapper function
/// for the specific map associated with that data-type.
/// You can do the same, or use it directly
/// to turn any arbitrary map into an accoutrement map.
///
/// @group core-api
/// @example scss - Access a map directly
///   $map: (
///     'original-value': 3em,
///     'new-value': '#original-value' ('times': 2, 'minus': 0.5),
///   );
///   /*! #{token-get($map, 'new-value')} */
/// @example scss - Write your own shortcut plugin for specific maps
///   $my-map: ('main': 32em);
///   @function get($key) { @return token-get($my-map, $key); }
///   /*! #{get('main')} */
///
/// @param {map} $map -
///   A map of token definitions to reference against
/// @param {*} $key -
///   The original key or value to be parsed for `#alias` tags
/// @return {*} -
///   Updated `$needle` value
///   in the same format as the original,
///   but with all `#alias` tags replaced
@function token-get(
  $map,
  $key
) {
  $key: map-get($map, $key) or $key;
  @return _a_get($map, $key);
}


// Get
// ---
/// Adds value/do functionality
/// to the value-parsing power of `_a_parse-alias()`.
/// Functions can be added as a map at the end of a value --
/// but some use-cases may confuse the parser,
/// so we provide a more explicit map option with a `value` key,
/// forllowed by functions and args.
///
/// @access private
///
/// @param {map} $map -
///   A map of token definitions to reference against
/// @param {*} $key -
///   Map access key for parsing
/// @return {*} -
///   Final parsed and adjusted value from the original map
@function _a_get(
  $map,
  $key
) {
  $type: type-of($key);
  $do: null;

  // break out `do` maps…
  @if ($type == 'map') {
    $value: map-get($key, 'value');
    $do: map-remove($key, 'value');

    @if ($value) {
      $key: $value;
    }
  } @else if ($type == 'list') {
    $final: nth($key, -1);

    @if (length($key) > 1) and (type-of($final) == 'map') {
      $do: $final;
      $key: _a_remove-nth($key, -1);
      $key: if(length($key) == 1, nth($key, 1), $key);
    }
  }

  // resolve any #alias tags…
  $key: _a_parse-alias($key, $map);
  $do: _a_parse-alias($do, $map);

  // make any necessary adjustments…
  @if ($do) {
    @each $function, $args in $do {
      $function: _a_get-function($function);
      $key: call($function, $key, $args...);
    }
  }

  @return $key;
}


// Parse Alias
// -----------
/// This provides the basis for recursively parsing
/// origin values of any kind,
/// and replacing any `#alias` tags
/// with the (parsed) values they represent.
///
/// @access private
///
/// @param {*} $needle -
///   The original value to be parsed for `#alias` tags
/// @param {map} $haystack -
///   A map of terms to reference tags against
/// @return {*} -
///   Updated `$needle` value
///   in the same format as the original,
///   but with all `#alias` tags replaced
@function _a_parse-alias(
  $needle,
  $haystack
) {
  // handle list values…
  @if (type-of($needle) == 'list') {
    $new: _a_list-template($needle);

    // handle each item in the list…
    @each $bit in $needle {
      $new: append($new, _a_parse-alias($bit, $haystack));
    }

    @return $new;
  }

  // handle map values…
  @if (type-of($needle) == 'map') {
    $new: ();

    // handle each value in the map…
    @each $key, $value in $needle {
      $key: _a_parse-alias($key, $haystack);
      $value: _a_parse-alias($value, $haystack);
      $needle: ($key: $value);
      $new: map-merge($new, $needle);
    }

    @return $new;
  }

  // recursively parse alias strings…
  @if (type-of($needle) == 'string') and str-index($needle, '#') {
    $alias-list: _a_get-alias-names($needle);

    @each $alias in $alias-list {
      @if map-has-key($haystack, $alias) {
        $reference: map-get($haystack, $alias);
        $reference: _a_get($haystack, $reference);
        $needle: _a_str-replace($needle, '##{$alias}', $reference, true);
      }
    }
  }

  @return $needle;
}
@include _a_register-function('_a_parse-alias');


// Get Alias Names
// ---------------
/// Search for `#alias` mentions within a string,
/// and return a list of unique mentions with `#` removed.
///
/// @access private
///
/// @param {string} $string -
///   The original string to be parsed for `#alias` tags
/// @return {list} -
///   List of unique `#alias` mentions with the `#` removed
@function _a_get-alias-names(
  $string
) {
  $found: ();
  $ends: (' ', '(', ')', '/', '\\', '#', '[', ']');
  $remainder: str-slice($string, str-index($string, '#') + 1);
  $end: str-length($remainder);

  @each $char in $ends {
    $n: str-index($remainder, $char);
    $end: if(($n) and ($n - 1 < $end), $n - 1, $end);
  }

  $found: append($found, str-slice($remainder, 1, $end));
  $remainder: str-slice($remainder, $end);

  @if str-index($remainder, '#') {
    @each $alias in _a_get-alias-names($remainder) {
      $found: if(index($found, $alias), $found, join($found, $alias));
    }
  }

  @return $found;
}
@include _a_register-function('_a_get-alias-names');

